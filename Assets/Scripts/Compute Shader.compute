// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSMain

// with cs.SetTexture
RWTexture2D<float4> Result;

// Same Struct as in C# but in HLSL
struct Person
{
    float2 position;
    float2 target_position;
    float speed_percentage;
    int health_status;
};

RWStructuredBuffer<Person> buffer;
RWStructuredBuffer<float2> debug_buffer;

// Variables
float global_speed;
float min_distance;
float PI;
float radius;
int number_of_sensors;

int texture_width;
int texture_height;



// Functions
float2 Move_Person(float2 current_position, float2 target_position, float speed);
float2 New_Target_Position(float seed);
void Draw_Edge_Circle(float start_x, float start_y, float radius,uint3 id);

[numthreads(512,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float person_speed = global_speed / buffer[id.x].speed_percentage;
    buffer[id.x].position = Move_Person(buffer[id.x].position, buffer[id.x].target_position, person_speed);

    if (buffer[id.x].position.x == buffer[id.x].target_position.x && buffer[id.x].position.y == buffer[id.x].target_position.y)
    {
        float2 new_target_position = New_Target_Position(sqrt(length(buffer[id.x].position)));
        //debug_buffer[id.x] = new_target_position;
        buffer[id.x].target_position = new_target_position;
    }
    
    //Draw_Edge_Circle(buffer[id.x].position.x, buffer[id.x].position.y, radius,id);
    
    if (id.x == 0)
    {
        Result[buffer[id.x].position] = float4(1, 0, 0, 0);
        Result[buffer[id.x].target_position] = float4(0, 1, 0, 0);
    }
    else
    {
        Result[buffer[id.x].position] = float4(1, 1, 1, 0);
    }
    
    
    
    [unroll(floor(360/number_of_sensors))]
    for (int i = 0; i <= 360; i += 360 / number_of_sensors)
    {
        float angle_in_radians = radians(i);
        float x_ratio = cos(angle_in_radians);
        float y_ratio = sin(angle_in_radians);
        float2 sensor_position = float2(buffer[id.x].position.x + (radius * x_ratio), buffer[id.x].position.y + (radius * y_ratio));
        Result[sensor_position] = float4(0, 1, 0, 0);
    }

} 

float2 Move_Person(float2 current_position, float2 target_position, float speed)
{
    float2 direction = target_position - current_position;
    
    float distance = length(direction);
    
    if (distance <= speed)
    {
        return target_position;
    }
    
    direction /= distance;
    
    float2 new_position = current_position + direction * speed;
    return new_position;
}


// Pseudo-Random Number Generator
float2 New_Target_Position(float seed)
{
    float random_decimal1 = frac(sin(seed * 12.5439) * 43758.5453);
    float random_decimal2 = frac(cos(seed * 12.5439) * 43758.5453);
    
    int new_target_position_x = lerp(0, texture_width, random_decimal1);
    int new_target_position_y = lerp(0, texture_height, random_decimal2);
    
    return float2(new_target_position_x, new_target_position_y);
}


void Draw_Edge_Circle(float start_x, float start_y, float radius, uint3 id)
{
    [unroll(10)]
    for (float i = 0; i < (2 * PI); i += (PI / 10))
    {
        float sensor_x = start_x + (radius * cos(i));
        float sensor_y = start_y + (radius * sin(i));
        
        Result[float2(floor(buffer[id.x].position.x + sensor_x), floor(buffer[id.x].position.y + sensor_y))] == float4(0, 1, 0, 1);
        debug_buffer[0] = i;
    }

}